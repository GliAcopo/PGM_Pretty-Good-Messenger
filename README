### Message handling
When authentication succeeds, the server thread dedicated to the client enters an infinite loop waiting for a `MESSAGE_CODE` value (enum in `3-Global-Variables-and-Functions.c`).  
Unless otherwise stated, every request receives an `ERROR_CODE` reply before any further payload exchange.

- `REQUEST_SEND_MESSAGE`:
    - Server receives a `MESSAGE` struct (with sender/recipient/length).
    - Server checks that the recipient folder exists.
        - If not found, reply with `USER_NOT_FOUND` and stop.
        - Otherwise reply with `NO_ERROR` and continue.
    - Server receives the message body (exactly `message_length` bytes).
    - Server creates a message file in the recipient folder named `<YYYYMMDDHHMMSS><file_suffix_user_data>`. Opened "exclusively" to avoid data access race among threads.
        - First bytes: serialized `MESSAGE` struct.
        - Then: raw message body.
        - File begins with an `UNREAD` marker (simple header line) to support unread loading.
- `REQUEST_LIST_REGISTERED_USERS`:
    - Server scans the base folder and lists every folder ending with `folder_suffix_user`.
    - Server replies with a newline-separated list of usernames (suffix stripped), ending with `\n`.
- `REQUEST_LOAD_MESSAGE`:
    - Server lists user message files, sorts by filename (descending), sends the list of filenames to the Client divided by newlines.
        - If list is to big @todo handle send of bigger data portions (is it even necessary?).
    - Server waits for `MESSAGE_CODE`
    - Client on his side prints to the user the sent list of filenames.
        - Client user chooses not to load any message.
            - Client responds with `OPERATION_ABORTED`
            - Server does nothing and restarts the loop
        - Client user chooses a message by writing the assigned number by the program listing.
            - Client responds to the server with `REQUEST_LOAD_SPECIFIC_MESSAGE`
            - Client then sends to the server the corresponding filename
            - Server searches for message in the user folder
                - if found, server responds with `NO_ERROR`
                    - Server sends message struct and message body
                        - IF the message contained the `UNREAD` marker then it gets removed
                - if not found server sends `MESSAGE_NOT_FOUND`
- `REQUEST_LOAD_UNREAD_MESSAGES`:
    - Server lists message files containing the `UNREAD` marker, in chronological order.
    - For each unread message, server sends the stored `MESSAGE` struct and message body.
    - After sending, server updates the marker removing the `UNREAD` header.
- `REQUEST_DELETE_MESSAGE`:
    - Works **exactly** as `REQUEST_LOAD_MESSAGE`, except for the fact that the selected message gets deleted.
        - if the deletion was a success then the server responds with `NO_ERROR`
        - if the deletion was a failure then the server responds with anything else.


### File and persistent storage
Only the server stores the messages, since the professor said that I cannot assume that I have storage permissions on Client devices.
- For every registered user, a folder with its name and `folder_suffix_user` is created.

- The file named with the name specified in the `password_filename` variable contains the user password.

- The file named with the name specified in the `data_filename` variable conains
    - First line: unsigned integer: number of messages received (currently in the folder)

- Every single file apart from those is a message:
    - Naming convention for the message files is `<date of receival><time of receival><file_suffix_user_data>`.
        - The format for the date is standard ISO 8601: YYYYMMDDHHMMSS without separators, so file fetching and ordering is easier.
    - The first thing to be stored in the file is the MESSAGE struct
    - then the message contents themselves

### Message exchange between two or more users
#### Logged in users management 
- At the start of the Server application, three relevant values are initialized:
    - `char* current_loggedin_users`: array of dynamically allocated usernames of currently logged in users
    - `unsigned int current_loggedin_users_bitmap`: The occupation bitmap of the array (initialized at 0)
    - `sem_t current_loggedin_users_semaphore`: The semaphore for synchronizing thread access to these resources.
    - Access to these resources always requires the semaphore, except for a debug-only dump on fatal errors.

When a connection is estabilished with the server, and the user authenticates, the server threads handling the connection:

- Enters a loop where it:
    - Tries to aquire the lock on the `current_loggedin_users_semaphore` for 5 seconds. (The system call is also checked for erroneus exit upon receiving SIGNAL)
    - If unable to, retries for up to `MAX_AQUIRE_SEMAPHORE_RETRY` (defined in `3-Global-Variables-and-Functions.h`).
    - If unable to, terminates the entire application.
        - _DEBUG: Every action is described and printed_

- Checks whether the username is already present in `current_loggedin_users`. If it is, the login is rejected.

- Allocates for the username of the logged in user (up to `USERNAME_SIZE_CHARS`) only after authentication succeeds.
    - _DEBUG: allocation is checked and printed_

- Checks the `current_loggedin_users_bitmap`, for an empty space. (That is, up until `MAX_BACKLOG` positions)
    - If found, the position index in the array is **saved** into a local variable `current_loggedin_users_used_index`.
        - _DEBUG: the bitmap is printed before and after the modification of the program_
    - There should never be an occasion in wich a free position is not found, since the lenght of the array is exactly how many users can be logged in at a time (that is `MAX_BACKLOG`)
        - _DEBUG: In that case, a DEBUG defined function `dump_loggedin_users()` gets called, said function prints the bitmap and the names of the loggedin users from the array (without aquiring semaphore) before closing the entire application_

- Writes the pointer to the allocated space to the name in the found array position.

- Restores `current_loggedin_users_semaphore` access.

Upon closing the connection, the thread cleanup routine includes:
- Enters a loop where it:
    - Tries to aquire the lock on the `current_loggedin_users_semaphore` for 5 seconds. (The system call is also checked for erroneus exit upon receiving SIGNAL)
    - If unable to, retries for up to `MAX_AQUIRE_SEMAPHORE_RETRY` (defined in `3-Global-Variables-and-Functions.h`).
    - If unable to, terminates the entire application.
        - _DEBUG: Every action is printed_

- Frees the `current_loggedin_users_used_index` entry number in the `current_loggedin_users` array.

- Removes the entry from the `current_loggedin_users_bitmap`.

Since this flow is a bit difficult to understand I have created a diagram:
![Server_users_management](Server Login and Logout Flow.pdf)

### Signal handling

## DEBUG
### Hold connection mode in the server
A debug-only mode to keep authenticated connections open for manual testing (for example to verify duplicate-login rejection and concurrent users).  
When enabled (proposed: `--hold` server argument or `PGM_HOLD_CONNECTION=1` env var), each authenticated thread enters a simple loop that blocks on the socket with a timeout, logs activity, and only exits on client disconnect or explicit stop.  
No message handling is implemented in this mode yet; it only keeps the session alive.
