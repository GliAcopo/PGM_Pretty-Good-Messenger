### Message handling
When authentication succeeds, the server thread dedicated to the client enters an infinite loop waiting for a `MESSAGE_CODE` value (enum in `3-Global-Variables-and-Functions.c`).  
Unless otherwise stated, every request receives an `ERROR_CODE` reply before any further payload exchange.

Note: unread messages are messages whose filename starts with the `UNREAD` flag
Note: the message count .DATA message count is to be discontinued, is not useful as a feature.
Note: When referring to "save the MESSAGE structure in the file" I mean that it is saved as WHOLE
- the structure contains a flexible array, so sizeof(MESSAGE) will not give the body of the message but only the first part of the structure.
    - Use offsetof(MESSAGE, message) + message_length bytes.
    - Do NOT use sizeof(MESSAGE).
- see `3-Global-Variables-and-Functions.h`->`MESSAGE STRUCT AND METHODS` for details.

- `REQUEST_SEND_MESSAGE`:
    - Server receives a `MESSAGE` struct (with sender/recipient/length).
    - Server checks that the recipient folder exists.
        - If not found, reply with `USER_NOT_FOUND` and stop.
        - Otherwise reply with `NO_ERROR` and continue.
    - Server receives the message body (exactly `message_length` bytes).
    - Server creates a message file in the recipient folder named `<YYYYMMDDHHMMSS><(num to avoid name clash)><file_suffix_user_data>`. Opened "exclusively" to avoid data access race among threads. ("num to avoid name clash" is used if a message is received in the same second, very unlikely but possible)
        - First bytes: serialized `MESSAGE` struct.
        - Then: raw message body.
        - NOTE: careful about network byte order
        - File is marked as `UNREAD` (filename starts with `UNREAD` as said above)
- `REQUEST_LIST_REGISTERED_USERS`:
    - Server scans the server folder and lists every folder ending with `folder_suffix_user`, (that is the names of the registered users)
    - Server replies with the number of bytes the communication will take.
        - Client replies with `NO_ERROR`
        - Else the operation gets aborted
    - Server replies with a newline-separated list of usernames (suffix stripped), null-terminated `\0`.
- `REQUEST_LOAD_MESSAGE`:
    - Server lists user message files, sorts by filename (only filenames in the directory, not the entire path) (descending), sends the list of filenames to the Client divided by newlines. Ends with null termination.
    - Server replies with the number of bytes the communication will take.
        - Client replies with `NO_ERROR`
        - Else the operation gets aborted
        - If list is to big @todo handle send of bigger data portions (is it even necessary?).
    - Server waits for `MESSAGE_CODE`
    - Client on his side prints to the user the sent list of filenames.
        - Client user chooses not to load any message.
            - Client responds with `MESSAGE_OPERATION_ABORTED`
            - Server does nothing and restarts the loop
        - Client user chooses a message by writing the assigned number by the program listing.
            - Client responds to the server with `REQUEST_LOAD_SPECIFIC_MESSAGE`
            - Client then sends to the server the corresponding filename
            - Server searches for message in the user folder
                - if found, server responds with `NO_ERROR`
                    - Server sends message struct and message body
                        - IF the message is `UNREAD` then the `UNREAD` marker gets removed from the filename
                - if not found server sends `MESSAGE_NOT_FOUND`
- `REQUEST_LOAD_UNREAD_MESSAGES`:
    - Behaves exactly like the first part of `REQUEST_LOAD_MESSAGE`, but only lists `UNREAD` messages.
    - After sending the list to the client, the loop restarts (no message sending is expected), that is because it is supposed to be used in conjuction with `REQUEST_LOAD_MESSAGE`.
- `REQUEST_DELETE_MESSAGE`:
    - Works **exactly** as `REQUEST_LOAD_MESSAGE`, except for the fact that the selected message gets deleted.
        - if the deletion was a success then the server responds with `NO_ERROR`
        - if the deletion was a failure then the server responds with anything else.


### File and persistent storage
Only the server stores the messages, since the professor said that I cannot assume that I have storage permissions on Client devices.
- For every registered user, a folder with its name and `folder_suffix_user` is created.

- The file named with the name specified in the `password_filename` variable contains the user password.

- The file named with the name specified in the `data_filename` variable conains
    - First line: unsigned integer: number of messages received (currently in the folder)

- Every single file apart from those is a message:
    - Naming convention for the message files is `<date of receival><time of receival><file_suffix_user_data>`.
        - The format for the date is standard ISO 8601: YYYYMMDDHHMMSS without separators, so file fetching and ordering is easier.
    - The first thing to be stored in the file is the MESSAGE struct
    - then the message contents themselves

### Message exchange between two or more users
#### Logged in users management 
- At the start of the Server application, three relevant values are initialized:
    - `char* current_loggedin_users`: array of dynamically allocated usernames of currently logged in users
    - `unsigned int current_loggedin_users_bitmap`: The occupation bitmap of the array (initialized at 0)
    - `sem_t current_loggedin_users_semaphore`: The semaphore for synchronizing thread access to these resources.
    - Access to these resources always requires the semaphore, except for a debug-only dump on fatal errors.

When a connection is estabilished with the server, and the user authenticates, the server threads handling the connection:

- Enters a loop where it:
    - Tries to aquire the lock on the `current_loggedin_users_semaphore` for 5 seconds. (The system call is also checked for erroneus exit upon receiving SIGNAL)
    - If unable to, retries for up to `MAX_AQUIRE_SEMAPHORE_RETRY` (defined in `3-Global-Variables-and-Functions.h`).
    - If unable to, terminates the entire application.
        - _DEBUG: Every action is described and printed_

- Checks whether the username is already present in `current_loggedin_users`. If it is, the login is rejected.

- Allocates for the username of the logged in user (up to `USERNAME_SIZE_CHARS`) only after authentication succeeds.
    - _DEBUG: allocation is checked and printed_

- Checks the `current_loggedin_users_bitmap`, for an empty space. (That is, up until `MAX_BACKLOG` positions)
    - If found, the position index in the array is **saved** into a local variable `current_loggedin_users_used_index`.
        - _DEBUG: the bitmap is printed before and after the modification of the program_
    - There should never be an occasion in wich a free position is not found, since the lenght of the array is exactly how many users can be logged in at a time (that is `MAX_BACKLOG`)
        - _DEBUG: In that case, a DEBUG defined function `dump_loggedin_users()` gets called, said function prints the bitmap and the names of the loggedin users from the array (without aquiring semaphore) before closing the entire application_

- Writes the pointer to the allocated space to the name in the found array position.

- Restores `current_loggedin_users_semaphore` access.

Upon closing the connection, the thread cleanup routine includes:
- Enters a loop where it:
    - Tries to aquire the lock on the `current_loggedin_users_semaphore` for 5 seconds. (The system call is also checked for erroneus exit upon receiving SIGNAL)
    - If unable to, retries for up to `MAX_AQUIRE_SEMAPHORE_RETRY` (defined in `3-Global-Variables-and-Functions.h`).
    - If unable to, terminates the entire application.
        - _DEBUG: Every action is printed_

- Frees the `current_loggedin_users_used_index` entry number in the `current_loggedin_users` array.

- Removes the entry from the `current_loggedin_users_bitmap`.

Since this flow is a bit difficult to understand I have created a diagram:
![Server_users_management](Server Login and Logout Flow.pdf)

### Signal handling

## DEBUG
### Hold connection mode in the server
A debug-only mode to keep authenticated connections open for manual testing (for example to verify duplicate-login rejection and concurrent users).  
When enabled (proposed: `--hold` server argument or `PGM_HOLD_CONNECTION=1` env var), each authenticated thread enters a simple loop that blocks on the socket with a timeout, logs activity, and only exits on client disconnect or explicit stop.  
No message handling is implemented in this mode yet; it only keeps the session alive.
